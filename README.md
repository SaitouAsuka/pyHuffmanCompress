# pyHuffmanCompress

利用python实现哈夫曼压缩算法，可以对文件进行压缩。

## 原理
### 压缩
哈夫曼树在数据结构这门课里面经常出现，主要作用是为了将字符按照出现频率进行编码。这里就不详细提及哈夫曼树的具体定义，只说如何构建哈夫曼树。

构建哈夫曼树需要对字符出现的频率进行统计，统计完之后按照频率从小到大从跟到叶节点进行递归构建。当当前的节点为最小频率的字符时，节点的左子树应该是该字符，右节点是递归构建的右子树，右子树所有的字符出现频率均比当前字符大。当出现两个节点频率一致，两个节点将会出现合并（当然出现的概率很小，我们可以忽略这种情况，这里的实现便是这样的，跟书本上的哈夫曼树略有不同）。我们定义当往右子树走的时候哈夫曼编码的前缀会加0，在递归构建哈夫曼树的时候可以新建一个哈希表记录字符对应的哈夫曼编码。

当构建好哈夫曼树以及哈夫曼编码后，我们可以把字符替换为对应的哈夫曼编码即可。接下来只需要根据对应的哈夫曼编码表就可以解压回原来的文件了。但是我们平时看到的压缩文件中，并不需要自己额外提供任何的对应表。这是因为已经将表的信息同时加到了压缩文件的头部区域。接下来详解还原哈夫曼解码表需要什么信息：

- 字符数目：需要知道有多少种字符，也就是对应的哈夫曼树有多少个叶子节点。只有通过这个才能确定后面保存的表的大小。一般是整数，我们这里可以用八个字节进行保存。
- 频率表：遍历所有的字符已经对应的频率，先保存字符，然后再保存对应的频率。注意频率也是整数，我们可以取整为八字节保存。这样我们可以直接根据前面的字符数目，把这些信息都读取出来。构建一个新的频率表。
- 消息本体长度：为什么会有消息本体长度，是因为文件是用8字节保存的，当末尾字节数不足八位的时候我们用零补全。但我们很容易知道，0理论上也是有对应的编码字符的，所以我们需要将补全的0去掉。故要保存消息本体长度。由于这个长度也是个整数，所以我们同样用8字节保存。

### 解压
解压的原理就只需要根据上面压缩的方式进行数据读取，然后利用频率表构建对应的哈夫曼树，接着对消息本体进行解压即可。

## 脚本使用以及示例

```
python main.py -h

usage: main.py [-h] --input INPUT --output OUTPUT [--dec]

    对文件进行压缩或者解压

    @para:input:输入文件
    @para:output:输出文件
    @para:dec:是否为解压[flag]
    

optional arguments:
  -h, --help            show this help message and exit
  --input INPUT, -i INPUT
                        输入文件, type:str
  --output OUTPUT, -o OUTPUT
                        输出文件, type:str
  --dec, -d             是否为解压[flag], deafult:False, it will be True if it's applied.
```
```
python main.py -i test.txt -o test.xyz
python main.py -i test.xyz -o test.detxt -d

 diff test.detxt test.txt
```